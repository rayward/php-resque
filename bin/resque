#!/usr/bin/env php
<?php

// Find and initialize Composer
$files = array(
    __DIR__ . '/../../vendor/autoload.php',
    __DIR__ . '/../../../autoload.php',
    __DIR__ . '/../../../../autoload.php',
    __DIR__ . '/../vendor/autoload.php',
);

$found = false;
foreach ($files as $file) {
    if (file_exists($file)) {
        require_once $file;
        break;
    }
}

if (!class_exists('Composer\Autoload\ClassLoader', false)) {
    die(
        'You need to set up the project dependencies using the following commands:' . PHP_EOL .
            'curl -s http://getcomposer.org/installer | php' . PHP_EOL .
            'php composer.phar install' . PHP_EOL
    );
}

use Psr\Log\LoggerInterface;
use Resque\Reserver\UnknownReserverException;
use DI\ContainerBuilder;

$builder = new ContainerBuilder();
$builder->useAnnotations(false);
$builder->addDefinitions(__DIR__ . '/../config/config.php');
$container = $builder->build();

if (empty($container->get('env.queue'))) {
    die("Set QUEUE env var containing the list of queues to work.\n");
}

/**
 * REDIS_BACKEND can have simple 'host:port' format or use a DSN-style format like this:
 * - redis://user:pass@host:port
 *
 * Note: the 'user' part of the DSN URI is required but is not used.
 */
if (!empty($container->get('env.redis.host'))) {
    if (empty($container->get('env.redis.db'))) {
        Resque::setBackend($container->get('env.redis.host'), $container->get('env.redis.db'));
    } else {
        Resque::setBackend($container->get('env.redis.host'));
    }
}

if ($container->get('env.app_include')) {
    $app_include = $container->get('env.app_include');
    if (!file_exists($app_include)) {
        die("APP_INCLUDE (${app_include}) does not exist.\n");
    }

    require_once $app_include;
}

// See if the APP_INCLUDE contains a logger object,
// If none exists, fallback to internal logger
if (isset($logger) && is_object($logger) && ($logger instanceof LoggerInterface)) {
    $container->set(LoggerInterface::class, $logger);
} else {
    $logger = $container->get(LoggerInterface::class);
}

if (!empty($container->get('env.redis.prefix'))) {
    $logger->info('Prefix set to {prefix}', ['prefix' => $container->get('env.redis.prefix')]);
    Resque_Redis::prefix($container->get('env.redis.prefix'));
}

$reserver = null;
try {
    $factory = $container->get('reserver.factory');
    if ($container->get('env.reserver')) {
        $reserver = $factory->createFromName($container->get('env.reserver'));
    } else {
        $reserver = $factory->createDefault();
    }
} catch (UnknownReserverException $exception) {
    die("Could not create reserver: " . $exception->getMessage());
}

if ($container->get('env.worker.count') > 1) {
    for ($i = 0; $i < $container->get('env.worker.count'); ++$i) {
        $pid = Resque::fork();
        if ($pid === false || $pid === -1) {
            $logger->emergency('Could not fork worker {count}', ['count' => $i]);
            die();
        } elseif (!$pid) {
            $worker = new Resque_Worker($reserver, $logger, $container->get('env.queues'));
            $logger->notice('Starting worker {worker}', ['worker' => (string)$worker]);
            $worker->work($container->get('env.worker.check_interval'));
            break;
        }
    }
} else {
    // Start a single worker
    $worker = new Resque_Worker($reserver, $logger, $container->get('env.queues'));

    $pidFile = $container->get('env.worker.pidfile');
    if ($pidFile) {
        if (!file_put_contents($pidFile, getmypid())) {
            die('Could not write PID information to ' . $pidFile);
        }
    }

    $logger->notice('Starting worker {worker}', ['worker' => (string)$worker]);
    $worker->work($container->get('env.worker.check_interval'));
}
